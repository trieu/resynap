
---
## Chapter 6: Automating Operational Tasks with AWS Lambda


---
## Introduction to AWS Lambda

*   AWS Lambda: A serverless compute service offering execution environments for various languages (C#/.NET Core, Go, Java, JavaScript/Node.js, Python, Ruby).
*   Function deployment: Implement a function, upload code, configure environment, and execute within a fully managed environment.
*   Integration: Seamless integration with other AWS services for operational task automation.
*   Benefits: Maintenance-free, highly available, pay-per-invocation billing (no idling costs).



---
## What is Serverless?

*   Serverless: A misnomer; servers still exist but are managed by AWS.  You don't manage the underlying infrastructure.
*   Criteria for a serverless system: No VM management, fully managed scalability and high availability, pay-per-request billing.
*   AWS Lambda as a serverless platform: AWS handles server configurations and management, making the server invisible to the user.
*   Competitors: Google Cloud Functions, Microsoft Azure Functions.



---
## Executing Code with AWS Lambda

*   Steps: Write code, upload code and dependencies, create a function defining the runtime environment and configuration, invoke the function.
*   Supported Runtimes: C#/.NET Core, Go, Java, JavaScript/Node.js, Python, Ruby, and custom runtimes.
*   Comparison with EC2: Lambda offers finer-grained virtualization (single functions vs. entire OS), managed infrastructure vs. self-managed, pay-per-execution vs. per-second billing.  Significant cost savings for infrequent tasks.



---
## Building a Website Health Check with AWS Lambda

*   Components: Lambda function (Python script for HTTP requests), EventBridge rule (triggers function every 5 minutes), CloudWatch alarm (monitors failures and sends email notifications).
*   Implementation: Using the Management Console to create and configure components manually.  Uses a pre-built blueprint (lambda-canary).
*   Environment Variables: `site` (website URL), `expected` (text to verify).



---
## Monitoring Lambda Functions with CloudWatch

*   Monitoring: Accessing Lambda function logs in CloudWatch.
*   Metrics: Invocations, Errors, Duration, Throttles.
*   Creating CloudWatch Alarms:  Setting up alarms based on metrics (e.g., Errors > 0) to trigger email notifications.



---
## Accessing Endpoints within a VPC

*   Default Lambda behavior: Lambda functions run outside VPCs but have internet access.
*   Accessing internal resources: Adding network interfaces to Lambda functions enables access to resources within VPCs (requires VPC, subnet, and security group configuration).  Use only when necessary due to increased complexity.



---
## Automating EC2 Instance Tagging with AWS Lambda

*   Use Case: Adding an "Owner" tag to EC2 instances automatically upon launch.  This helps with cost allocation, access control, and instance management.
*   Event-driven approach: Subscribing to EventBridge events generated by CloudTrail (AWS API calls).
*   Event Pattern: Filtering events based on source, detail-type, eventSource, and eventName (e.g., `RunInstances`).



---
## Implementing the Lambda Function (Python)

*   Lambda Function Code (Python): Uses boto3 (AWS SDK for Python) to create EC2 tags based on the CloudTrail event data. Extracts the username and instance ID from the event.
*   Serverless Application Model (SAM):  Simplifies deploying Lambda functions with CloudFormation.  Provides a framework extending CloudFormation templates.



---
## Authorizing Lambda Functions with IAM Roles

*   IAM Roles: Lambda functions assume IAM roles to authenticate and authorize requests to other AWS services.
*   Least Privilege Principle: Granting only necessary permissions in IAM policies.
*   Custom Policy:  Adding a policy to allow `ec2:CreateTags` for the Lambda function.



---
## Deploying a Lambda Function with SAM

*   Deployment Package: Creating a zip file containing code and dependencies.
*   Deployment Process: Using `aws cloudformation package` and `aws cloudformation deploy` commands to upload the package to S3 and deploy the CloudFormation stack.



---
## Limitations of AWS Lambda

*   Execution Time Limit: Maximum execution time of 15 minutes.
*   Cold Starts: Latency introduced when a new execution context is created (mitigated by smaller deployment packages, more memory, and choosing appropriate runtimes).
*   Provisioned Concurrency:  Keeping execution contexts warm to avoid cold starts (costs apply even when idle).
*   Memory Limit: Maximum memory allocation of 10,240 MB.
*   Deployment Package Size: Maximum compressed size of 250 MB.
*   Temporary Disk Space: Up to 512 MB of non-persistent disk space in `/tmp`.



---
## Serverless Pricing Model

*   Pay-per-request billing: Costs are incurred only when the function is invoked.
*   Free Tier: 1 million requests and 400,000 seconds of compute time with 1 GB memory per month (x86 and ARM).  Does not expire after 12 months.
*   Cost Components: Request count and execution duration (based on memory provisioned).



---
## Additional Use Cases for AWS Lambda

*   Web Applications: Building backends using API Gateway and Lambda.
*   Data Processing: Event-driven data processing triggered by changes in object storage.
*   IoT Backends: Processing sensor data from IoT devices.



---
## Summary of Key Concepts

*   AWS Lambda's capabilities, benefits, and limitations.
*   Serverless architecture and its components.
*   Using the Management Console, SAM, and AWS CLI for deployment.
*   IAM roles for authorization.
*   Monitoring with CloudWatch.
*   Various use cases for Lambda functions.

